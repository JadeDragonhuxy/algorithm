package com.example.system.algorithm.sort;

import java.util.Arrays;

/**
 * @Project: algorithm
 * @Package: com.example.demo.algorithm.logarithm
 * @ClassName: InsertionSort
 * @Author: huxy
 * @Date: 2020/11/23 9:50
 * @Version: 1.0
 * @Description: 插入排序算法
 *               排序思想：指针从0位置出发依次遍历每一个位置的数，当指针指向哪一个位置通过比较交换使0位置到指针位置的区间有序。
 *                       其中当指针指向某一位置是，该位置数值依次向其前一位置的数值比较，如果前一位置数值大于指针所在数值，则交换；
 *                       直到指针数值不再小于前一位置数值或者指针数值之前没有数值时结束。
 *               举例：(1)要排序数组:[3,2,3,1,4,0]
 *                    (2)从0位置出发，使0到0位置有序，0到0位置只有‘3’，本来就有序，无需交换。
 *                       排序后数组为：[3,2,3,1,4,0]
 *                    (3)指针移到1位置，需要使0到1位置有序，1位置的数为‘2’，1位置之前的数为‘3’，2<3,交换；
 *                       再往前看，没数字了，结束；操作后得到0位置到1位置有序。
 *                       排序后数组为：[2,3,3,1,4,0]
 *                    (4)指针移到2位置，需要使0到2位置有序，2位置的数为‘3’，2位置之前的数为‘2,3’，
 *                       首先，2位置数先与离得最近的1位置数比较，3!<3，不交换；
 *                       直接结束，不需要继续往前比较；操作后得到0位置到2位置有序。
 *                       排序后数组为：[2,3,3,1,4,0]
 *                    (5)指针移到3位置，需要使0到3位置有序，3位置的数为‘1’，3位置之前的数为‘2,3,3’，
 *                       首先，3位置数先与离得最近的2位置数比较，1<3，交换；1再往前看与1位置的数比较，1<3,交换；
 *                       1再往前看与0位置的数比较，1<2,交换；1再往前看，没数了，结束；
 *                       所以3位置1交换到0位置，0位置到2位置依次后移，操作后得到0位置到3位置有序。
 *                       排序后数组为：[1,2,3,3,4,0]
 *                    (6)指针移到4位置，需要使0到4位置有序，4位置的数为‘4’，4位置之前的数为‘1,2,3,3’，
 *                       首先，4位置数先与离得最近的3位置数比较，4!<3，不交换，直接结束；操作后得到0位置到4位置有序。
 *                       排序后数组为：[1,2,3,3,4,0]
 *                    (7)指针移到5位置，需要使0到5位置有序，5位置的数为‘0’，5位置之前的数为‘1,2,3,3,4’，
 *                       0依次与前面的数比较，比所有数都小，直到0位置为止，结束；操作后整个有序。
 *                       排序后数组为：[0,1,2,3,3,4]
 *               时间复杂度： 最优情况数组本来就有序：每个数只需要与前一个数查看比较一次，因而最优时间为：O(n);
 *                          但是在最差情况下，数组本来逆序：
 *                          到0位置需要比较交换0次
 *                          到1位置需要比较交换1次
 *                          到2位置需要比较交换2次
 *                          。。。。
 *                          到n-1位置，需要比较交换n-1次
 *                          时间复杂度计算为：n+(n-1)+(n-2)+(n-3)+...+2+1 = a*n^2+b*n+c （等差数列）
 *                          ====================================================================
 *                          因此：时间复杂度为：O(n^2) （时间复杂度取最差的情况）
 *              空间复杂度： 算法中只使用了基本数据类型变量，因而空间复杂度为O(1)
 *
 *              学习日期：2020年11月23日，9:59（学习进度有点慢呀，加油）
 */
public class InsertionSort {

    public static void insertSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }

        for (int i = 1; i < arr.length; i++) {//i控制0到i位置数有序,直到最后0到n-1位置有序
            for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {//j控制当在i位置时，i位置数与其之前的数进行比较，直到没有数或者前一个数不大于i位置数为止
                swap(arr, j, j + 1);//前一个数比其大，进行交换
            }
        }

    }

    private static void swap(int[] arr, int i, int j) {
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }

    public static void main(String[] args) {
        int[] arr = {
                1, 5, 2, 4, 6, 2, 5, 7, 99, 34, 54
        };
        System.out.println("排序前：" + Arrays.toString(arr));
        insertSort(arr);
        System.out.println("排序后：" + Arrays.toString(arr));
    }

}
